<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://openlayers.org/en/v4.6.5/css/ol.css" type="text/css">
  <link rel="stylesheet" href="css/demo.css" type="text/css">
</head>
<body>
<div id="map">
  <div class="grid-params">
    <li>计算范围：<input type="text" id="bound" value="118,20,130,30"></li>
    <li>网格大小：<input type="text" id="size" value="0.25"></li>
    <li><input type="button" value="生成网格" onclick="generateGrid()"> </li>
  </div>
</div>
<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script src="https://openlayers.org/en/v4.6.5/build/ol.js"></script>
<script src="js/demo.js"></script>
<script src="datas/china.js"></script>
<script>
  var vec_w = getTilelayer("dark");
  var numLon, numLat;
  var data = [];
  var landData;
  map = new ol.Map({
    controls: ol.control.defaults({
      attribution: false
    }),
    target: 'map',
    layers: [vec_w],
    view: new ol.View({
      center: ol.proj.fromLonLat([98.633, 31.607]),
      zoom:4,
      minZoom:0,
      maxZoom:18
    })
  });

  var source = new ol.source.Vector({
    features: []
  });
  var vector = new ol.layer.Vector({
    source: source,
    zIndex: 1,
    opacity: 0.65,
    style: styleFunction
  });
  map.addLayer(vector);
  
  function styleFunction(feat) {
    // i为lat，j为lon
    var i = feat.get("i"),
      j = feat.get("j");

    var e = feat.getGeometry().getExtent();
    var coord = [
      (e[0] + e[2])/2,
      (e[1] + e[1])/2
    ];
    
    if(isOnLand(coord)) {
      var val = data[i][j];
      var color;
      if (val > 0.33 && val <= 0.66) {
        color = "orange";
      } else if (val > 0.66 && val <= 1) {
        color = "red";
      } else {
        color = 'yellow';
      }
      return new ol.style.Style({
        image: new ol.style.Circle({
          radius: 5,
          stroke: new ol.style.Stroke({
            color: 'red', width: 1
          }),
          fill: new ol.style.Fill({
            color: color,
          })
        }),
        stroke: new ol.style.Stroke({
          color: 'grey',
          width: 1
        }),
        fill: new ol.style.Fill({
          color: color,
        })
      })
    }
  }

  function generateGrid() {
    var bound = $("#bound").val(),
      size = Number($("#size").val());
    var bounds = bound.split(",").map(Number);
    var gridData = createGrid(bounds, size);
    var format = new ol.format.GeoJSON();
    var options = {
      dataProjection: 'EPSG:4326',
      featureProjection: 'EPSG:3857'
    };
    // var centFeatures = format.readFeatures(gridData.center, options);
    var gridFeatures = format.readFeatures(gridData.grid, options);
    source.addFeatures(gridFeatures);
    landData = format.readFeatures(chinaZone, options);
  }
  
  function isOnLand(coord) {
    var is = false;
    for(var i = 0;i<landData.length;i++){
      var geom = landData[i].getGeometry();
      if (geom.intersectsCoordinate(coord)) {
        is = true;
        break;
      }
    }
    return is;
  }

  /**
   * 创建网格
   * @param bound
   * @param size
   * @returns {{grid: {features: Array, type: string}, center: {features: Array, type: string}}}
   */
  function createGrid(bound, size) {
    var grid = {
      type: "FeatureCollection",
      features: []
    };
    var center = {
      type: "FeatureCollection",
      features: []
    };

    var deltaLon = bound[2] - bound[0],
      deltaLat = bound[3] - bound[1];
    numLon = Math.ceil(deltaLon / size);
    numLat = Math.ceil(deltaLat/ size);
    var minLon = bound[0],
      maxLat = bound[3];
    for(var i = 0; i < numLat; i++) {
      var lat1 = maxLat - i * size,
        lat2 = maxLat - (i + 1) * size;
      var latC = (lat1 + lat2) / 2;
      data[i] = [];
      for(var j = 0; j < numLon; j++) {
        data[i][j] = Math.random()
        var lon1 = minLon + j * size,
          lon2 = minLon + (j + 1) * size;
        var lonC = (lon1 + lon2) / 2;
        var prop = {
          i: i,
          j: j
        };
        // 网格面
        var featG = {
          "type":"Feature",
          "properties": prop,
          "geometry":{
            "type":"Polygon",
            "coordinates":[[
              [lon1, lat1],
              [lon2, lat1],
              [lon2, lat2],
              [lon1, lat2],
              [lon1, lat1]
            ]]
          }
        };
        grid.features.push(featG);
        // 中心点
        var featC = {
          "type":"Feature",
          "properties": prop,
          "geometry":{
            "type":"Point",
            "coordinates":[lonC, latC]
          }
        };
        center.features.push(featC);
      }
    }
    return {
      grid: grid,
      center: center
    }
  }
</script>
</body>
