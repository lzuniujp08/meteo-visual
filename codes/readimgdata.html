<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <link rel="stylesheet" href="https://openlayers.org/en/v4.6.5/css/ol.css" type="text/css">
  <link rel="stylesheet" href="css/demo.css" type="text/css">
</head>
<body>
<div id="map"></div>
<div id="popup"></div>
<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script src="https://openlayers.org/en/v4.6.5/build/ol.js"></script>
<script src="js/demo.js"></script>
<script>
  var vec_w = getWmsLayer("light");
  var geoBounds = [70, 15, 140, 60];
  var imgPixels = [];
  var width = 0,
    height = 0,
    dx = 0,
    dy = 0;
  var bounds = ol.proj.transformExtent(geoBounds, 'EPSG:4326',"EPSG:3857");
  map = new ol.Map({
    controls: ol.control.defaults({
      attribution: false
    }),
    target: 'map',
    layers: [vec_w],
    view: new ol.View({
      center: ol.proj.fromLonLat([98.633, 31.607]),
      zoom:4,
      minZoom:0,
      maxZoom:18
    })
  });
  var popup = new ol.Overlay({
    element: document.getElementById('popup'),
    position: null,
    positioning: 'center-left',
    offset: [16, 0]
  });
  map.addOverlay(popup);
  addLegend();
  var intervalPixel = 100;
  map.on('pointermove', function (e) {
    var geoPt = ol.proj.toLonLat(e.coordinate);
    var val = getVal(geoPt);
    if(val) {
      document.getElementById('popup').innerText = val.toFixed(1);
      popup.setPosition(e.coordinate);
    } else  {
      popup.setPosition(null);
    }
  });
  
  map.on("moveend", function () {
    _source.clear();
      var extent = map.getView().calculateExtent();
      var geoExtent = ol.proj.transformExtent(extent, 'EPSG:3857', 'EPSG:4326');
      var lonmin, lonmax, latmin, latmax;
      lonmin = geoExtent[0] > geoBounds[0] ? geoExtent[0] : geoBounds[0];
      latmin = geoExtent[1] < geoBounds[1] ? geoExtent[1] : geoBounds[1];
      lonmax = geoExtent[2] > geoBounds[2] ? geoExtent[2] : geoBounds[2];
      latmax = geoExtent[3] < geoBounds[3] ? geoExtent[3] : geoBounds[3];
      var topLeft = [lonmin, latmax];
      var topLeft3857 = ol.proj.fromLonLat(topLeft);
      var topLeftPixel = map.getPixelFromCoordinate(topLeft3857);
      var topLeftSetPixel = [topLeftPixel[0] + intervalPixel, topLeftPixel[1]];
      var topLeftSet3857 = map.getCoordinateFromPixel(topLeftSetPixel);
      var topLeftSet = ol.proj.toLonLat(topLeftSet3857);
      var intervalDegree = topLeftSet[0] - topLeft[0];
      var nx = Math.floor((lonmax - lonmin) / intervalDegree),
        ny = Math.floor((latmax - latmin) / intervalDegree * 2);
      var _features = [];
      // y是固定的，x根据奇偶行变换
      for(var i = 0;i<=ny;i++) {
        var lat = latmax - i * intervalDegree / 2;
        var lonAdd = i%2 !==0 ? intervalDegree / 2 : 0;
        for(var j=0;j<=nx;j++) {
          var lon = lonmin + j * intervalDegree;
          lon = lon + lonAdd ;
          var lonLat = [lon + dx/2, lat + dy/2];
          var coord = ol.proj.fromLonLat(lonLat);
          if(ol.extent.containsCoordinate(extent, coord)) {
            var val = getVal(lonLat);
            _features.push(new ol.Feature({
              geometry: new ol.geom.Point(coord),
              val: val
            }));
          }
        }
      }
      _source.addFeatures(_features);
  });
  

  var imageLayer = new ol.layer.Image({
    source: null,
    opacity: 0.85
  });
  map.addLayer(imageLayer);

  var textLayer = new ol.layer.Vector({
    source: null,
    opacity: 0.85,
    style: function (feat) {
      var val = feat.get("val");
      if(val) {
        return new ol.style.Style({
          text: new ol.style.Text({
            font: 'normal 14px 黑体',
            text: val.toFixed(1),
            fill: new ol.style.Fill({
              color: '#ff0000'
            }),
            stroke: new ol.style.Stroke({
              color: '#ffff',
              width: 2
            })
          })
        })
      } else {
        return null;
      }
      
    }
  });
  map.addLayer(textLayer);
  var _source = new ol.source.Vector({
    features: []
  });
  textLayer.setSource(_source);
  
  var img = new Image();
  img.src = 'css/ws_china.png';
  img.onload = function () {
    var canvas = document.createElement('canvas');
    width = img.width;
    height = img.height;
    dx = (geoBounds[2] - geoBounds[0])/width;
    dy = (geoBounds[3] - geoBounds[1])/height;
    canvas.height = height;
    canvas.width = width;
    document.body.appendChild(canvas);
    var ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0);
    imgPixels = ctx.getImageData(0, 0, width, height);
    var image = ctx.createImageData(width, height);
    // canvas先绘制行，在绘制列
    for(var j = 0;j<height;j++){
      for(var i = 0;i<width;i++){
        var _ji = (j * 4) * width + i * 4;
        var r = imgPixels.data[_ji], g = imgPixels.data[_ji+1] ,b = imgPixels.data[_ji+2];
        var val = r * 256 + g + b * 0.01;
        val = Number(val.toFixed(2));
        var c = getColor(val);
        image.data[_ji + 0] = parseInt(c[0]);
        image.data[_ji + 1] = parseInt(c[1]);
        image.data[_ji + 2] = parseInt(c[2]);
        image.data[_ji + 3] = val === 0 ? 0 : parseInt(c[3]);
      }
    }
    ctx.putImageData(image, 0, 0);

    var source = new ol.source.ImageStatic({
      url: canvas.toDataURL("image/png"),
      imageExtent: bounds
    });
    imageLayer.setSource(source);
  };
  
  function getVal(geoPt) {
    var x = parseInt((geoPt[0] - geoBounds[0]) / dx),
      y = parseInt((geoBounds[3] - geoPt[1]) / dy);
    if(x >= 0 && y >= 0 && x < width && y < height) {
      var _ji = (y * 4) * width + x * 4;
      if (imgPixels.data[_ji + 2]) {
        var r = imgPixels.data[_ji], g = imgPixels.data[_ji + 1], b = imgPixels.data[_ji + 2];
        var val = r * 256 + g + b * 0.01;
        return val;
      }
    }
  }
</script>
</body>
</html>
